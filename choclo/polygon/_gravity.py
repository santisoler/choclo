"""
Gravity forward modelling for 2D polygons.
"""

import numba
import numpy as np

from ..constants import GRAVITATIONAL_CONST


# @numba.jit(nopython=True)
def gravity_u(x: float, upward: float, polygon: np.ndarray, density: float):
    r"""
    Upward component of the gravity acceleration due to a 2D polygon.

    Parameters
    ----------
    x, upward : float
        Horizontal and upward coordinates of the observation point.
        Must be in meters.
    polygon : (n_vertices, 2) np.ndarray
        Array containing the coordinates horizontal and upward coordinates of
        the polygon vertices. Vertices should be provided in clockwise order.
        Their coordinates must be in meters.
    density : float
        Density of the polygon in kilograms per cubic meter.

    Returns
    -------
    float
        Upward component of the gravitational acceleration generated by the
        rectangular prism on the observation point in
        :math:`\text{m}/\text{s}^2`.
    """
    n_vertices, _ = polygon.shape
    result = 0.0
    for i in range(n_vertices):
        # Get shifted coordinates of pair of vertices
        xi = polygon[i, 0] - x
        zi = polygon[i, 1] - upward
        if i == n_vertices - 1:
            xii = polygon[0, 0] - x
            zii = polygon[0, 1] - upward
        else:
            xii = polygon[i + 1, 0] - x
            zii = polygon[i + 1, 1] - upward

        # Evaluate limits
        if xi == 0.0 and xii == 0.0:
            continue
        if zi == 0.0 and zii == 0.0:
            continue
        if xi == zi == 0.0:
            continue
        if xii == zii == 0.0:
            continue

        theta_i = np.arctan2(zi, xi)
        theta_ii = np.arctan2(zii, xii)

        if theta_i == theta_ii:
            continue
        if xi == xii:
            result += xi * np.log(np.cos(theta_i) / np.cos(theta_ii))
            continue
        if zi == zii:
            result += zi * (theta_ii - theta_i)
            continue

        a_i = xii + zii * (xii - xi) / (zi - zii)
        tan_phi_i = (zii - zi) / (xii - xi)
        phi_i = np.arctan2(zii - zi, xii - xi)

        if xi == 0.0:
            tan_theta_ii = zii / xii
            result += (
                -a_i
                * np.sin(phi_i)
                * np.cos(phi_i)
                * (
                    theta_ii
                    - np.pi / 2
                    + tan_phi_i * np.log(np.cos(theta_ii) * (tan_theta_ii - tan_phi_i))
                )
            )
            continue
        if xii == 0.0:
            tan_theta_i = zi / xi
            result += (
                a_i
                * np.sin(phi_i)
                * np.cos(phi_i)
                * (
                    theta_i
                    - np.pi / 2
                    + tan_phi_i * np.log(np.cos(theta_i) * (tan_theta_i - tan_phi_i))
                )
            )
            continue

        tan_theta_i = zi / xi
        tan_theta_ii = zii / xii
        log = np.log(
            (np.cos(theta_i) * (tan_theta_i - tan_phi_i))
            / (np.cos(theta_ii) * (tan_theta_ii - tan_phi_i))
        )
        result += (
            a_i * np.sin(phi_i) * np.cos(phi_i) * (theta_i - theta_ii + tan_phi_i * log)
        )
    # Use a minus to invert the sign of the result (return the upward component)
    return -2 * GRAVITATIONAL_CONST * density * result
